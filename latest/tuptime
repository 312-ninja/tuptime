#!/usr/bin/env python
# -*- coding: utf-8 -*-

# tuptime - Report the historical and statistical running time of the system, keeping it between restarts.
# Copyright (C) 2011-2015 - Ricardo F.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

try:
    import sys, os, optparse, sqlite3, locale, platform, subprocess, time
    from datetime import datetime
except Exception as e:
    sys.exit('ERROR modules are not imported correctly: ' + str(e))

version = '3.0.00'
def_db_file = '/var/lib/tuptime/tuptime.db'
def_seconds = False
locale.setlocale(locale.LC_ALL, '')
def_date_format = '%X %x'
dec = int(2)  # Decimals for printed values


def vprint(*args):
    """Print verbose information"""
    if opt.verbose:
        for arg in args:
            sys.stdout.write(str(arg))
        print('')


def maxwidth(table, index):
    """Get the maximum width of the given column index"""
    return max([len(str(row[index])) for row in table])


def pprint_table(table):
    """Print formated table"""
    colpad = []
    side_spaces=3

    for i in range(len(table[0])):
        colpad.append(maxwidth(table, i))

    for row in table:
        sys.stdout.write(str(row[0]).ljust(colpad[0]))
        for i in range(1, len(row)):
            col = str(row[i]).rjust(colpad[i] + side_spaces)
            sys.stdout.write(str(''+  col))
        print ('')


def time_conv(secs):
    """Convert seconds to human readable syle"""
    try:
        if secs == 0:
            return '0 seconds'

        tm = {'years': int(0), 'days': int(0), 'hours': int(0), 'minutes': int(0), 'seconds': int(0)}
        tm_tuple = ('years', 'days', 'hours', 'minutes', 'seconds')
        zero_enter = True
        human_tm = ''

        # Get times values
        tm['minutes'], tm['seconds'] = divmod(secs, 60)
        tm['hours'], tm['minutes'] = divmod(tm['minutes'], 60)
        tm['days'], tm['hours'] = divmod(tm['hours'], 24)
        tm['years'], tm['days'] = divmod(tm['days'], 365)

        for key in tm_tuple:  # avoid print empty values at the beginning
            if tm[key] == 0 and zero_enter:
                continue
            else:
                human_tm += str(int(tm[key]))+' '+str(key) + ', '
                zero_enter = False

        if human_tm.find('minutes, '):  # nice sentence end, remove comma
            human_tm = human_tm.replace('minutes, ', 'minutes and ')

        return str(human_tm[:-2])  # return without last comma and space chareacter
    except Exception as e:
        sys.exit('ERROR converting seconds: '+ str(e))


def main():
    global opt

    # - Reading command line parameters
    parser = optparse.OptionParser()
    parser.add_option('-d', '--date',
        dest='date_format',
        default=def_date_format,
        action='store',
        help='date format output')
    parser.add_option('-e', '--end',
        dest='end',
        default=False,
        action='store_true',
        help='order by end state (only with -t or -l)')
    parser.add_option('-f', '--filedb',
        dest='db_file',
        default=def_db_file,
        action='store',
        help='database file',
        metavar='FILE')
    parser.add_option('-g', '--graceful',
        dest='endst',
        action='store_const',
        default='0',
        const='1',
        help='register a gracefully shutdown')
    parser.add_option('-l', '--list',
        dest='lst',
        default=False,
        action='store_true',
        help='enumerate system life as list')
    parser.add_option('-o', '--offtime',
        dest='offbtime',
        default=False,
        action='store_true',
        help='order by offtime (only with -t or -l)')
    parser.add_option('-r', '--reverse',
        dest='reverse',
        default=False,
        action='store_true',
        help='reverse order (only with -t or -l)')
    parser.add_option('-s', '--seconds',
        dest='seconds',
        default=def_seconds,
        action='store_true',
        help='output time in seconds and epoch')
    parser.add_option('-t', '--table',
        dest='table',
        default=False,
        action='store_true',
        help='enumerate system life as table')
    parser.add_option('-u', '--uptime',
        dest='uptime',
        default=False,
        action='store_true',
        help='order by uptime (only with -t or -l)')
    parser.add_option('-x', '--silent',
        dest='silent',
        default=False,
        action='store_true',
        help='update values into db without output')
    parser.add_option('-v', '--verbose',
        dest='verbose',
        default=False,
        action='store_true',
        help='verbose output')
    parser.add_option('-V', '--version',
        dest='version',
        default=False,
        action='store_true',
        help='show version')
    opt, _ = parser.parse_args()

    # - Parse version option
    if opt.version:
        print ('tuptime version ' + version)
        sys.exit(0)

    # - Swich for running in FreeBSD or Linux
    if (platform.system() == "FreeBSD"):
        # procfs = "/compat/linux/proc"
        try:  # Get sysctl values
            sysctl = subprocess.check_output(['/sbin/sysctl', 'kern.boottime']);
            sec = sysctl.split()[4].replace(',','')
            btime = int(sec)
            uptime = float((time.time() - btime))
            vprint('uptime = ' + str(uptime))
            vprint('btime = ' + str(btime))
        except Exception as e:
            sys.exit('ERROR reading sysctl ' + str(e))
    else:
        procfs = "/proc"
        # - Reading /proc/uptime
        try:
            with open(procfs + '/uptime') as fl:
                uptime = float(fl.readline().split()[0])
                vprint(procfs + '/uptime = ' + str(uptime))
        except Exception as e:
            sys.exit('ERROR reading ' + procfs + '/uptime'+ str(e))

        # - Reading btime from /proc/stat
        try:
            with open(procfs + '/stat') as fl:
                for line in fl:
                    if line.startswith('btime'):
                        btime = int(line.split()[1])
                vprint(procfs + '/stat btime = ' + str(btime))
        except Exception as e:
            sys.exit('ERROR reading ' + procfs + '/stat'+ str(e))

    # - Assure state of db file
    try:
        if os.path.isdir(os.path.dirname(opt.db_file)):
            vprint('Directory exists = ', os.path.dirname(opt.db_file))
        else:
            vprint('Creating directory = ', opt.db_file)
            os.makedirs(os.path.dirname(opt.db_file))

        if os.path.isfile(opt.db_file):
            vprint('DB file exists = ', opt.db_file)
            try:  # Test db version
                db = sqlite3.connect(opt.db_file)
                conn = db.cursor()
                conn.execute('pragma table_info(tuptime)')
                table_info=conn.fetchall()
                db.commit()
                db.close()
                if len(table_info) == 3:
                    print('Database file with old format')
                    print('Please, execute this script: https://github.com/rfrail3/tuptime/blob/master/scripts/db-tuptime-migrate.sh')
                    sys.exit('ERROR Invalid db file format')
            except Exception as e:
                sys.exit('ERROR testing db format')
        else:
            vprint('Creating DB file = ', opt.db_file)
            db = sqlite3.connect(opt.db_file)
            conn = db.cursor()
            conn.execute('create table if not exists tuptime(uptime real, btime integer, endst integer, downtime real, offbtime integer)')
            conn.execute('insert into tuptime values (?,?,?,?,?)', (str(uptime), str(btime), str(opt.endst), str('-1'), str('-1')))
            db.commit()
            db.close()
    except Exception as e:
        sys.exit('ERROR creating db file: '+ str(e))

    # - Creating db connection
    try:
        db = sqlite3.connect(opt.db_file)
        conn = db.cursor()
    except Exception as e:
        sys.exit('ERROR connecting db: '+ str(e))

    # - Reading last btime registered in db
    try:
        conn.execute('select btime, uptime from tuptime where oid = (select max(oid) from tuptime)')
        last_btime, last_uptime = conn.fetchone()
        vprint('Last btime from db = ', last_btime)
        vprint('Last uptime from db = ', str(last_uptime))
        lasts = last_uptime + last_btime
    except Exception as e:
        sys.exit('ERROR reading from db: '+ str(e))


    # - Test if system was resterted
    # How tuptime do it:
    #    Checking if last_btime saved into db plus uptime is lower than actual btime
    #
    # In some particular cases the btime value from /proc/stat may change. Testing only last_btime vs
    # actual btime can produce a false endst register.
    # Usually happend on virtualized enviroments, servers with high load or when ntp are running.
    # Related to kernel system clock frequency, computation of jiffies / HZ and the problem of lost ticks.
    # More info in Debian bug 119971 and rfc1589
    #
    # For avoid problems with extreme corner cases, please be sure that the init/systemd script and 
    # cron line works as expected.

    try:
        if (last_btime + uptime) < btime:
            vprint('System was restarted')
            conn.execute('update tuptime set downtime = '+ str(round((btime - lasts), 2)) +', offbtime = '+ str(lasts) +' where oid = (select max(oid) from tuptime)')  # Save downtimes for previous boot
            conn.execute('insert into tuptime values (?,?,?,?,?)', (str(uptime), str(btime), str(opt.endst), str('-1'), str('-1')))  # Create entry for new boot
        else:
            vprint('System wasn\'t restarted. Updating db values...')
            conn.execute('update tuptime set uptime = '+ str(uptime) +', endst = '+ str(opt.endst) +' where oid = (select max(oid) from tuptime)')
    except Exception as e:
        if type(e).__name__ == 'OperationalError':
            vprint('WARNING values not saved into db - Test file permissions')
        vprint('WARNING ', str(e))
        if (last_btime + uptime) < btime:
            # If you see this error, maybe systemd script isn't executed at startup
            # or the db file (def_db_file) have wrong permissions.
            sys.exit('ERROR After system restart, the values must be saved into db. Please, execute tuptime with a privileged user.')

    if opt.silent:
        vprint('Only update')
        sys.exit()            
    else:
        vprint('')

    # - Print each row registered in db
    if (opt.lst or opt.table) and not opt.silent:
        keys_dict = ('startup', 'uptime', 'btime', 'endst', 'downtime', 'offbtime')
        if opt.table:
            tbl = []  # Initialize table with header
            tbl.append(['Nº', 'Startup Date', 'Uptime', 'Shutdown Date', 'End', 'Offtime'])
            tbl.append([''] * len(tbl[0]))

        # Construct keywords and order type
        if opt.uptime or opt.offbtime or opt.end:
            eq_by=[]
            if opt.reverse:
                eq_order='asc'
            else:
                eq_order='desc'
            if opt.uptime:
                eq_by.append('uptime')
            if opt.offbtime:
                eq_by.append('offbtime')
            if opt.end:
                eq_by.append('endst')
        else:
            eq_by=['oid']
            if opt.reverse:
                eq_order='desc'
            else:
                eq_order='asc'
        eq_by =", ".join(eq_by)

        print(eq_by)
        conn.execute('select oid, * from tuptime order by offbtime asc')
        db_rows = conn.fetchall()

        for db_row_value in db_rows:
            vprint('Processing row ' + str(db_row_value))
            row_dict = dict(zip(keys_dict, db_row_value))  # join key + value for db row

            if row_dict['endst'] == 1:
                e_end = 'OK'
            else:
                e_end = 'BAD'

            if opt.seconds:
                e_btime = row_dict['btime']
                e_uptime = round(row_dict['uptime'], dec)
                e_uptime_only = round(uptime, dec)
                e_offbtime = row_dict['offbtime']
                e_downtime = round(row_dict['downtime'], dec)
            else:
                e_btime = datetime.fromtimestamp(row_dict['btime']).strftime(opt.date_format)
                e_uptime = time_conv(row_dict['uptime'])
                e_uptime_only = time_conv(uptime)
                e_offbtime = datetime.fromtimestamp(row_dict['offbtime']).strftime(opt.date_format)
                e_downtime = time_conv(row_dict['downtime'])
            e_startup = row_dict['startup']

            if opt.lst:  # Print list values
                print('Startup:  ' + str(e_startup) + '  at  '+ str(e_btime))
                if e_startup == len(db_rows):  # Avoid last shutdown and hack for unprivileged users
                    print('Uptime:   ' + str(e_uptime_only))
                else:
                    print('Uptime:   ' + str(e_uptime))
                    print('Shutdown: ' + str(e_end) + '  at  '+ str(e_offbtime))
                if row_dict['downtime'] >= 0:   # Avoid '-1' registers
                    print('Downtime: ' + str(e_downtime))
                print('')

            if opt.table:  # Fill table
                if row_dict['downtime'] >= 0:   # Avoid '-1' registers
                    if e_startup == len(db_rows):
                        tbl.append([str(e_startup), str(e_btime), str(e_uptime_only), str(e_offbtime), str(e_end), str(e_downtime)])
                    else:
                        tbl.append([str(e_startup), str(e_btime), str(e_uptime), str(e_offbtime), str(e_end), str(e_downtime)])
                else:
                    tbl.append([str(e_startup), str(e_btime), str(e_uptime_only), str(''), str(''), str('')])

        # - Print table
        if opt.table:
            if opt.lst:
                print('')
            pprint_table(tbl)

        # - Closing db connection
        try:
            db.commit()
            db.close()
            sys.exit()            
        except Exception as e:
            sys.exit('ERROR closing db connection at enumerate: '+ str(e))

    # - Get number of startups
    conn.execute('select max(oid) from tuptime')
    startups = int(conn.fetchone()[0])

    # - Get first btime
    conn.execute('select btime from tuptime limit 1')
    first_btime = int(conn.fetchone()[0])

    # - Get total uptime
    # conn.execute('select sum(uptime) from tuptime')
    # hack for allow unprivileged users that can not update database show results
    conn.execute('select sum(uptime) from tuptime where oid < (select max(oid) from tuptime)')
    total_uptime = sum(filter(None, [conn.fetchone()[0], uptime]))

    # - Get shutdowns states
    conn.execute('select count(endst) from tuptime where endst = 0 and oid < (select max(oid) from tuptime)')
    bad_shdown = int(conn.fetchone()[0])
    ok_shdown = startups - bad_shdown - 1

    # - Get life time
    conn.execute('select btime from tuptime where oid = (select min(oid) from tuptime)')
    first_btime = int(conn.fetchone()[0])
    sys_life = (btime + uptime) - first_btime

    if startups > 1:
        # The following two uptime queries select all rows minus last row for allow unprivileged users that can not 
        # update database show correct results. The last two downtime don't need last row
        # Large uptime
        conn.execute('select max(uptime), btime from tuptime where oid < (select max(oid) from tuptime)')
        larg_up_uptime, larg_up_btime = conn.fetchone()
        # Short uptime
        conn.execute('select min(uptime), btime from tuptime where oid < (select max(oid) from tuptime)')
        shrt_up_uptime, shrt_up_btime = conn.fetchone()
        # Large dowtime
        conn.execute('select max(downtime), btime, uptime from tuptime where oid < (select max(oid) from tuptime)')
        larg_down_downtime, larg_down_btime, larg_down_uptime = conn.fetchone()
        larg_down_offtime = larg_down_btime + larg_down_uptime
        # Short dowtime
        conn.execute('select min(downtime), btime, uptime from tuptime where oid < (select max(oid) from tuptime)')
        shrt_down_downtime, shrt_down_btime, shrt_down_uptime = conn.fetchone()
        shrt_down_offtime = shrt_down_btime + shrt_down_uptime
    else:  # Initialize empty values
        larg_up_uptime = 0; larg_up_btime = 0
        shrt_up_uptime = 0; shrt_up_btime = 0
        larg_down_downtime = 0; larg_down_offtime = 0
        shrt_down_downtime = 0; shrt_down_offtime = 0

    # - Closing db connection
    try:
        db.commit()
        db.close()
    except Exception as e:
        sys.exit('ERROR closing db connection: '+ str(e))

    # Supersede the last row values for large/short uptime if is applicable.
    if larg_up_uptime <= uptime or larg_up_btime == 0:
        larg_up_uptime = uptime
        larg_up_btime = btime
    if shrt_up_uptime > uptime or shrt_up_btime == 0:
        shrt_up_uptime = uptime
        shrt_up_btime = btime

    # - Get average uptime and uptime rate
    average = float(total_uptime / startups)
    uprate = float((total_uptime * 100 ) / (sys_life))
    if startups == 1:
        total_downtime = 0
    else:
        total_downtime = float(sys_life - total_uptime)
    downrate = abs(float((total_downtime * 100 ) / (sys_life)))
    average_down = float(total_downtime / startups)

    if opt.seconds:
        average = round(average, dec)
        average_down = round(average_down, dec)
        total_uptime = round(total_uptime, dec)
        total_downtime = round(total_downtime, dec)
        sys_life = round(sys_life, dec)
    else:
        # - Values in human readable style
        first_btime = datetime.fromtimestamp(first_btime).strftime(opt.date_format)
        larg_up_uptime = time_conv(larg_up_uptime)
        larg_up_btime = datetime.fromtimestamp(larg_up_btime).strftime(opt.date_format)
        average = time_conv(total_uptime / startups)
        shrt_up_uptime = time_conv(shrt_up_uptime)
        shrt_up_btime = datetime.fromtimestamp(shrt_up_btime).strftime(opt.date_format)
        larg_down_downtime = time_conv(larg_down_downtime)
        larg_down_offtime = datetime.fromtimestamp(larg_down_offtime).strftime(opt.date_format)
        average_down = time_conv(total_downtime / startups)
        shrt_down_downtime = time_conv(shrt_down_downtime)
        shrt_down_offtime = datetime.fromtimestamp(shrt_down_offtime).strftime(opt.date_format)
        uptime = time_conv(uptime)
        btime = datetime.fromtimestamp(btime).strftime(opt.date_format)
        total_uptime = time_conv(total_uptime)
        total_downtime = time_conv(total_downtime)
        sys_life = time_conv(sys_life)

    print('System startups:\t' + str(startups) + '   since   ' + str(first_btime))
    print('System shutdowns:\t' + str(ok_shdown) + ' ok   -   ' + str(bad_shdown) + ' bad')
    print('System uptime: \t\t' + str(round(uprate, dec)) + ' %   -   ' + str(total_uptime))
    print('System downtime: \t' + str(round(downrate, dec)) + ' %   -   ' + str(total_downtime))
    print('System life: \t\t' + str(sys_life))
    print('')
    print('Largest uptime:\t\t'+ str(larg_up_uptime) + '   from   ' + str(larg_up_btime))    
    print('Shortest uptime:\t'+ str(shrt_up_uptime) + '   from   ' + str(shrt_up_btime))    
    print('Average uptime: \t' + str(average))
    print('')
    if startups == 1:
        print('Largest downtime:\t'+ str(larg_down_downtime))    
        print('Shortest downtime:\t'+ str(shrt_down_downtime))    
    else:
        print('Largest downtime:\t'+ str(larg_down_downtime) + '   from   ' + str(larg_down_offtime))    
        print('Shortest downtime:\t'+ str(shrt_down_downtime) + '   from   ' + str(shrt_down_offtime))    
    print('Average downtime: \t' + str(average_down))
    print('')
    print('Current uptime: \t' + str(uptime) + '   since   ' + str(btime))

if __name__ == "__main__":
    print('Non working code!')
    main()
